/*
 * Hetzner Cloud API
 *
 * Copied from the official API documentation for the Public Hetzner Cloud.
 *
 * The version of the OpenAPI document: 76113aa-dirty
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};

/// struct for passing parameters to the method [`add_records_to_rrset`]
#[derive(Clone, Debug, Default)]
pub struct AddRecordsToRrsetParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub rr_name: String,
    pub rr_type: String,
    pub add_records_to_rrset_request: models::AddRecordsToRrsetRequest,
}

/// struct for passing parameters to the method [`change_rrsets_protection`]
#[derive(Clone, Debug, Default)]
pub struct ChangeRrsetsProtectionParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub rr_name: String,
    pub rr_type: String,
    pub change_rrsets_protection_request: models::ChangeRrsetsProtectionRequest,
}

/// struct for passing parameters to the method [`change_rrsets_ttl`]
#[derive(Clone, Debug, Default)]
pub struct ChangeRrsetsTtlParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub rr_name: String,
    pub rr_type: String,
    pub change_rrsets_ttl_request: models::ChangeRrsetsTtlRequest,
}

/// struct for passing parameters to the method [`change_zones_default_ttl`]
#[derive(Clone, Debug, Default)]
pub struct ChangeZonesDefaultTtlParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub change_zones_default_ttl_request: models::ChangeZonesDefaultTtlRequest,
}

/// struct for passing parameters to the method [`change_zones_primary_nameservers`]
#[derive(Clone, Debug, Default)]
pub struct ChangeZonesPrimaryNameserversParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub change_zones_primary_nameservers_request: models::ChangeZonesPrimaryNameserversRequest,
}

/// struct for passing parameters to the method [`change_zones_protection`]
#[derive(Clone, Debug, Default)]
pub struct ChangeZonesProtectionParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub change_zones_protection_request: models::ChangeZonesProtectionRequest,
}

/// struct for passing parameters to the method [`create_rrset`]
#[derive(Clone, Debug, Default)]
pub struct CreateRrsetParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub resource_record_set_to_create: models::ResourceRecordSetToCreate,
}

/// struct for passing parameters to the method [`create_zone`]
#[derive(Clone, Debug, Default)]
pub struct CreateZoneParams {
    pub create_zone_request: models::CreateZoneRequest,
}

/// struct for passing parameters to the method [`delete_rrset`]
#[derive(Clone, Debug, Default)]
pub struct DeleteRrsetParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub rr_name: String,
    pub rr_type: String,
}

/// struct for passing parameters to the method [`delete_zone`]
#[derive(Clone, Debug, Default)]
pub struct DeleteZoneParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
}

/// struct for passing parameters to the method [`export_zone_file`]
#[derive(Clone, Debug, Default)]
pub struct ExportZoneFileParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
}

/// struct for passing parameters to the method [`get_action_for_zone`]
#[derive(Clone, Debug, Default)]
pub struct GetActionForZoneParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    /// ID of the Action.
    pub action_id: i64,
}

/// struct for passing parameters to the method [`get_rrset`]
#[derive(Clone, Debug, Default)]
pub struct GetRrsetParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub rr_name: String,
    pub rr_type: String,
}

/// struct for passing parameters to the method [`get_zone`]
#[derive(Clone, Debug, Default)]
pub struct GetZoneParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
}

/// struct for passing parameters to the method [`get_zone_action`]
#[derive(Clone, Debug, Default)]
pub struct GetZoneActionParams {
    /// ID of the Action.
    pub id: i64,
}

/// struct for passing parameters to the method [`import_zone_file`]
#[derive(Clone, Debug, Default)]
pub struct ImportZoneFileParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub import_zone_file_request: models::ImportZoneFileRequest,
}

/// struct for passing parameters to the method [`list_actions_for_zone`]
#[derive(Clone, Debug, Default)]
pub struct ListActionsForZoneParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    /// Sort actions by field and direction. Can be used multiple times. For more information, see \"Sorting\".
    pub sort: Option<Vec<String>>,
    /// Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.
    pub status: Option<Vec<String>>,
    /// Page number to return. For more information, see \"Pagination\".
    pub page: Option<i64>,
    /// Maximum number of entries returned per page. For more information, see \"Pagination\".
    pub per_page: Option<i64>,
}

/// struct for passing parameters to the method [`list_rrsets`]
#[derive(Clone, Debug, Default)]
pub struct ListRrsetsParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    /// Filter resources by their name. The response will only contain the resources matching exactly the specified name.
    pub name: Option<String>,
    /// Filter resources by their type. Can be used multiple times. The response will only contain resources matching the specified types.
    pub r#type: Option<Vec<String>>,
    /// Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \"Label Selector\".
    pub label_selector: Option<String>,
    /// Sort resources by field and direction. Can be used multiple times. For more information, see \"Sorting\".
    pub sort: Option<Vec<String>>,
    /// Page number to return. For more information, see \"Pagination\".
    pub page: Option<i64>,
    /// Maximum number of entries returned per page. For more information, see \"Pagination\".
    pub per_page: Option<i64>,
}

/// struct for passing parameters to the method [`list_zone_actions`]
#[derive(Clone, Debug, Default)]
pub struct ListZoneActionsParams {
    /// Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.
    pub id: Option<Vec<i64>>,
    /// Sort actions by field and direction. Can be used multiple times. For more information, see \"Sorting\".
    pub sort: Option<Vec<String>>,
    /// Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.
    pub status: Option<Vec<String>>,
    /// Page number to return. For more information, see \"Pagination\".
    pub page: Option<i64>,
    /// Maximum number of entries returned per page. For more information, see \"Pagination\".
    pub per_page: Option<i64>,
}

/// struct for passing parameters to the method [`list_zones`]
#[derive(Clone, Debug, Default)]
pub struct ListZonesParams {
    /// Filter resources by their name. The response will only contain the resources matching exactly the specified name.
    pub name: Option<String>,
    /// Filter resources by their mode. The response will only contain the resources matching exactly the specified mode.
    pub mode: Option<String>,
    /// Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \"Label Selector\".
    pub label_selector: Option<String>,
    /// Sort resources by field and direction. Can be used multiple times. For more information, see \"Sorting\".
    pub sort: Option<Vec<String>>,
    /// Page number to return. For more information, see \"Pagination\".
    pub page: Option<i64>,
    /// Maximum number of entries returned per page. For more information, see \"Pagination\".
    pub per_page: Option<i64>,
}

/// struct for passing parameters to the method [`remove_records_from_rrset`]
#[derive(Clone, Debug, Default)]
pub struct RemoveRecordsFromRrsetParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub rr_name: String,
    pub rr_type: String,
    pub remove_records_from_rrset_request: models::RemoveRecordsFromRrsetRequest,
}

/// struct for passing parameters to the method [`replace_rrset`]
#[derive(Clone, Debug, Default)]
pub struct ReplaceRrsetParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub rr_name: String,
    pub rr_type: String,
    pub replace_rrset_request: models::ReplaceRrsetRequest,
}

/// struct for passing parameters to the method [`replace_zone`]
#[derive(Clone, Debug, Default)]
pub struct ReplaceZoneParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub replace_zone_request: models::ReplaceZoneRequest,
}

/// struct for passing parameters to the method [`set_records_of_rrset`]
#[derive(Clone, Debug, Default)]
pub struct SetRecordsOfRrsetParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub rr_name: String,
    pub rr_type: String,
    pub set_records_of_rrset_request: models::SetRecordsOfRrsetRequest,
}

/// struct for passing parameters to the method [`update_records_of_rrset`]
#[derive(Clone, Debug, Default)]
pub struct UpdateRecordsOfRrsetParams {
    /// ID or Name of the Zone.
    pub id_or_name: String,
    pub rr_name: String,
    pub rr_type: String,
    pub update_records_of_rrset_request: models::UpdateRecordsOfRrsetRequest,
}

/// struct for typed errors of method [`add_records_to_rrset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddRecordsToRrsetError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_rrsets_protection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeRrsetsProtectionError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_rrsets_ttl`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeRrsetsTtlError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_zones_default_ttl`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeZonesDefaultTtlError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_zones_primary_nameservers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeZonesPrimaryNameserversError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_zones_protection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeZonesProtectionError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_rrset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRrsetError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_zone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateZoneError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_rrset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRrsetError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_zone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteZoneError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export_zone_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportZoneFileError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_action_for_zone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActionForZoneError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rrset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRrsetError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_zone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetZoneError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_zone_action`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetZoneActionError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`import_zone_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImportZoneFileError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_actions_for_zone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListActionsForZoneError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_rrsets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRrsetsError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_zone_actions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListZoneActionsError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_zones`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListZonesError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_records_from_rrset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveRecordsFromRrsetError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`replace_rrset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceRrsetError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`replace_zone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceZoneError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_records_of_rrset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetRecordsOfRrsetError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_records_of_rrset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRecordsOfRrsetError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// Adds resource records (RRs) to an RRSet in the Zone.  For convenience, the RRSet will be automatically created if it doesn't exist. Otherwise, the new records are appended to the existing RRSet.  Only applicable for Zones in primary mode.  #### Call specific error codes  | Code                  | Description                      | |-----------------------|----------------------------------| | `incorrect_zone_mode` | The zone is not in primary mode. |
pub async fn add_records_to_rrset(
    configuration: &configuration::Configuration,
    params: AddRecordsToRrsetParams,
) -> Result<models::AddRecordsToRrsetResponse, Error<AddRecordsToRrsetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let rr_name = params.rr_name;
    let rr_type = params.rr_type;
    let add_records_to_rrset_request = params.add_records_to_rrset_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/rrsets/{rr_name}/{rr_type}/actions/add_records",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name),
        rr_name = crate::apis::urlencode(rr_name),
        rr_type = crate::apis::urlencode(rr_type)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&add_records_to_rrset_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AddRecordsToRrsetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Changes the protection of an RRSet in the Zone.  Only applicable for Zones in primary mode.  #### Call specific error codes  | Code                  | Description                      | |-----------------------|----------------------------------| | `incorrect_zone_mode` | The zone is not in primary mode. |
pub async fn change_rrsets_protection(
    configuration: &configuration::Configuration,
    params: ChangeRrsetsProtectionParams,
) -> Result<models::ChangeRrsetsProtectionResponse, Error<ChangeRrsetsProtectionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let rr_name = params.rr_name;
    let rr_type = params.rr_type;
    let change_rrsets_protection_request = params.change_rrsets_protection_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/rrsets/{rr_name}/{rr_type}/actions/change_protection",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name),
        rr_name = crate::apis::urlencode(rr_name),
        rr_type = crate::apis::urlencode(rr_type)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&change_rrsets_protection_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChangeRrsetsProtectionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Changes the Time To Live (TTL) of an RRSet in the Zone.  Only applicable for Zones in primary mode.  #### Call specific error codes  | Code                  | Description                      | |-----------------------|----------------------------------| | `incorrect_zone_mode` | The zone is not in primary mode. |
pub async fn change_rrsets_ttl(
    configuration: &configuration::Configuration,
    params: ChangeRrsetsTtlParams,
) -> Result<models::ChangeRrsetsTtlResponse, Error<ChangeRrsetsTtlError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let rr_name = params.rr_name;
    let rr_type = params.rr_type;
    let change_rrsets_ttl_request = params.change_rrsets_ttl_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/rrsets/{rr_name}/{rr_type}/actions/change_ttl",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name),
        rr_name = crate::apis::urlencode(rr_name),
        rr_type = crate::apis::urlencode(rr_type)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&change_rrsets_ttl_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChangeRrsetsTtlError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Changes the default Time To Live (TTL) of a Zone.  This TTL is used for RRSets that do not explicitly define a TTL.  Only applicable for Zones in primary mode.  #### Call specific error codes  | Code                  | Description                      | |-----------------------|----------------------------------| | `incorrect_zone_mode` | The zone is not in primary mode. |
pub async fn change_zones_default_ttl(
    configuration: &configuration::Configuration,
    params: ChangeZonesDefaultTtlParams,
) -> Result<models::ChangeZonesDefaultTtlResponse, Error<ChangeZonesDefaultTtlError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let change_zones_default_ttl_request = params.change_zones_default_ttl_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/actions/change_ttl",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&change_zones_default_ttl_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChangeZonesDefaultTtlError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Overwrites the primary nameservers of a Zone.  Only applicable for Zones in secondary mode.  #### Call specific error codes  | Code                  | Description                        | |-----------------------|------------------------------------| | `incorrect_zone_mode` | The zone is not in secondary mode. |
pub async fn change_zones_primary_nameservers(
    configuration: &configuration::Configuration,
    params: ChangeZonesPrimaryNameserversParams,
) -> Result<models::ChangeZonesPrimaryNameserversResponse, Error<ChangeZonesPrimaryNameserversError>>
{
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let change_zones_primary_nameservers_request = params.change_zones_primary_nameservers_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/actions/change_primary_nameservers",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&change_zones_primary_nameservers_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChangeZonesPrimaryNameserversError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Changes the protection configuration of a Zone.
pub async fn change_zones_protection(
    configuration: &configuration::Configuration,
    params: ChangeZonesProtectionParams,
) -> Result<models::ChangeZonesProtectionResponse, Error<ChangeZonesProtectionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let change_zones_protection_request = params.change_zones_protection_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/actions/change_protection",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&change_zones_protection_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChangeZonesProtectionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create an RRSet in the Zone.  Only applicable for Zones in primary mode.  | Code                  | Description                      | |-----------------------|----------------------------------| | `incorrect_zone_mode` | The zone is not in primary mode. |
pub async fn create_rrset(
    configuration: &configuration::Configuration,
    params: CreateRrsetParams,
) -> Result<models::CreateRrsetResponse, Error<CreateRrsetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let resource_record_set_to_create = params.resource_record_set_to_create;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/rrsets",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&resource_record_set_to_create);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateRrsetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a Zone.  A default `SOA` and three `NS` resource records with the assigned Hetzner nameservers are created automatically.
pub async fn create_zone(
    configuration: &configuration::Configuration,
    params: CreateZoneParams,
) -> Result<models::CreateZoneResponse, Error<CreateZoneError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let create_zone_request = params.create_zone_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!("{}/zones", local_base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_zone_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateZoneError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes an RRSet from the Zone.  Only applicable for Zones in primary mode.  | Code                  | Description                      | |-----------------------|----------------------------------| | `incorrect_zone_mode` | The zone is not in primary mode. |
pub async fn delete_rrset(
    configuration: &configuration::Configuration,
    params: DeleteRrsetParams,
) -> Result<models::DeleteRrsetResponse, Error<DeleteRrsetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let rr_name = params.rr_name;
    let rr_type = params.rr_type;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/rrsets/{rr_name}/{rr_type}",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name),
        rr_name = crate::apis::urlencode(rr_name),
        rr_type = crate::apis::urlencode(rr_type)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteRrsetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a Zone.
pub async fn delete_zone(
    configuration: &configuration::Configuration,
    params: DeleteZoneParams,
) -> Result<models::DeleteZoneResponse, Error<DeleteZoneError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteZoneError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a generated Zone file in BIND (RFC [1034](https://datatracker.ietf.org/doc/html/rfc1034)/[1035](https://datatracker.ietf.org/doc/html/rfc1035)) format.  Only applicable for Zones in primary mode.  #### Call specific error codes  | Code                  | Description                      | |-----------------------|----------------------------------| | `incorrect_zone_mode` | The zone is not in primary mode. |
pub async fn export_zone_file(
    configuration: &configuration::Configuration,
    params: ExportZoneFileParams,
) -> Result<models::ExportZoneFileResponse, Error<ExportZoneFileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/zonefile",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ExportZoneFileError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a specific Action for a Zone.
pub async fn get_action_for_zone(
    configuration: &configuration::Configuration,
    params: GetActionForZoneParams,
) -> Result<models::GetActionResponse, Error<GetActionForZoneError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let action_id = params.action_id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/actions/{action_id}",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name),
        action_id = action_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetActionForZoneError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a single RRSet from the Zone.  Only applicable for Zones in primary mode.  #### Call specific error codes  | Code                  | Description                      | |-----------------------|----------------------------------| | `incorrect_zone_mode` | The zone is not in primary mode. |
pub async fn get_rrset(
    configuration: &configuration::Configuration,
    params: GetRrsetParams,
) -> Result<models::GetRrsetResponse, Error<GetRrsetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let rr_name = params.rr_name;
    let rr_type = params.rr_type;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/rrsets/{rr_name}/{rr_type}",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name),
        rr_name = crate::apis::urlencode(rr_name),
        rr_type = crate::apis::urlencode(rr_type)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRrsetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a single Zone.
pub async fn get_zone(
    configuration: &configuration::Configuration,
    params: GetZoneParams,
) -> Result<models::GetZoneResponse, Error<GetZoneError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetZoneError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a specific Action.
pub async fn get_zone_action(
    configuration: &configuration::Configuration,
    params: GetZoneActionParams,
) -> Result<models::GetActionResponse, Error<GetZoneActionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!("{}/zones/actions/{id}", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetZoneActionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Imports a zone file, replacing all resource record sets (RRSets).  The import will fail if existing RRSet are `change` protected.  See Zone file import for more details. Only applicable for Zones in primary mode.  #### Call specific error codes  | Code                  | Description                      | |-----------------------|----------------------------------| | `incorrect_zone_mode` | The zone is not in primary mode. |
pub async fn import_zone_file(
    configuration: &configuration::Configuration,
    params: ImportZoneFileParams,
) -> Result<models::ImportZoneFileResponse, Error<ImportZoneFileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let import_zone_file_request = params.import_zone_file_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/actions/import_zonefile",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&import_zone_file_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ImportZoneFileError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all Actions for a Zone.  Use the provided URI parameters to modify the result.
pub async fn list_actions_for_zone(
    configuration: &configuration::Configuration,
    params: ListActionsForZoneParams,
) -> Result<models::ListActionsResponse, Error<ListActionsForZoneError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let sort = params.sort;
    let status = params.status;
    let page = params.page;
    let per_page = params.per_page;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/actions",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sort {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("sort".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "sort",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("status".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "status",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListActionsForZoneError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all RRSets in the Zone.  Use the provided URI parameters to modify the result.  The maximum value for `per_page` on this endpoint is `100` instead of `50`.  Only applicable for Zones in primary mode.  #### Call specific error codes  | Code                  | Description                      | |-----------------------|----------------------------------| | `incorrect_zone_mode` | The zone is not in primary mode. |
pub async fn list_rrsets(
    configuration: &configuration::Configuration,
    params: ListRrsetsParams,
) -> Result<models::ListRrsetsResponse, Error<ListRrsetsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let name = params.name;
    let r#type = params.r#type;
    let label_selector = params.label_selector;
    let sort = params.sort;
    let page = params.page;
    let per_page = params.per_page;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/rrsets",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = name {
        local_var_req_builder =
            local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = r#type {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("type".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "type",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = label_selector {
        local_var_req_builder =
            local_var_req_builder.query(&[("label_selector", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("sort".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "sort",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListRrsetsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all Zone Actions.  Use the provided URI parameters to modify the result.
pub async fn list_zone_actions(
    configuration: &configuration::Configuration,
    params: ListZoneActionsParams,
) -> Result<models::ListActionsResponse, Error<ListZoneActionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let sort = params.sort;
    let status = params.status;
    let page = params.page;
    let per_page = params.per_page;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!("{}/zones/actions", local_base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "id",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("sort".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "sort",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("status".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "status",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListZoneActionsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all Zones.  Use the provided URI parameters to modify the result.
pub async fn list_zones(
    configuration: &configuration::Configuration,
    params: ListZonesParams,
) -> Result<models::ListZonesResponse, Error<ListZonesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let mode = params.mode;
    let label_selector = params.label_selector;
    let sort = params.sort;
    let page = params.page;
    let per_page = params.per_page;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!("{}/zones", local_base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = name {
        local_var_req_builder =
            local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = mode {
        local_var_req_builder =
            local_var_req_builder.query(&[("mode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = label_selector {
        local_var_req_builder =
            local_var_req_builder.query(&[("label_selector", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("sort".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "sort",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListZonesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes resource records (RRs) from an existing RRSet in the Zone.  For convenience, the RRSet will be automatically deleted if it doesn't contain any RRs afterwards.  Only applicable for Zones in primary mode.  #### Call specific error codes  | Code                  | Description                      | |-----------------------|----------------------------------| | `incorrect_zone_mode` | The zone is not in primary mode. |
pub async fn remove_records_from_rrset(
    configuration: &configuration::Configuration,
    params: RemoveRecordsFromRrsetParams,
) -> Result<models::RemoveRecordsFromRrsetResponse, Error<RemoveRecordsFromRrsetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let rr_name = params.rr_name;
    let rr_type = params.rr_type;
    let remove_records_from_rrset_request = params.remove_records_from_rrset_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/rrsets/{rr_name}/{rr_type}/actions/remove_records",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name),
        rr_name = crate::apis::urlencode(rr_name),
        rr_type = crate::apis::urlencode(rr_type)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&remove_records_from_rrset_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RemoveRecordsFromRrsetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates an RRSet in the Zone.  Only applicable for Zones in primary mode.  | Code                  | Description                      | |-----------------------|----------------------------------| | `incorrect_zone_mode` | The zone is not in primary mode. |
pub async fn replace_rrset(
    configuration: &configuration::Configuration,
    params: ReplaceRrsetParams,
) -> Result<models::ReplaceRrsetResponse, Error<ReplaceRrsetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let rr_name = params.rr_name;
    let rr_type = params.rr_type;
    let replace_rrset_request = params.replace_rrset_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/rrsets/{rr_name}/{rr_type}",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name),
        rr_name = crate::apis::urlencode(rr_name),
        rr_type = crate::apis::urlencode(rr_type)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&replace_rrset_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReplaceRrsetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a Zone.  To modify resource record sets (RRSets), use the RRSet Actions endpoints.
pub async fn replace_zone(
    configuration: &configuration::Configuration,
    params: ReplaceZoneParams,
) -> Result<models::ReplaceZoneResponse, Error<ReplaceZoneError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let replace_zone_request = params.replace_zone_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&replace_zone_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReplaceZoneError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Overwrites the resource records (RRs) of an existing RRSet in the Zone.  Only applicable for Zones in primary mode.  #### Call specific error codes  | Code                  | Description                      | |-----------------------|----------------------------------| | `incorrect_zone_mode` | The zone is not in primary mode. |
pub async fn set_records_of_rrset(
    configuration: &configuration::Configuration,
    params: SetRecordsOfRrsetParams,
) -> Result<models::SetRecordsOfRrsetResponse, Error<SetRecordsOfRrsetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let rr_name = params.rr_name;
    let rr_type = params.rr_type;
    let set_records_of_rrset_request = params.set_records_of_rrset_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/rrsets/{rr_name}/{rr_type}/actions/set_records",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name),
        rr_name = crate::apis::urlencode(rr_name),
        rr_type = crate::apis::urlencode(rr_type)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&set_records_of_rrset_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetRecordsOfRrsetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates resource records' (RRs) comments of an existing RRSet in the Zone.  Only applicable for Zones in primary mode.  #### Call specific error codes  | Code                  | Description                      | |-----------------------|----------------------------------| | `incorrect_zone_mode` | The zone is not in primary mode. |
pub async fn update_records_of_rrset(
    configuration: &configuration::Configuration,
    params: UpdateRecordsOfRrsetParams,
) -> Result<models::UpdateRecordsOfRrsetResponse, Error<UpdateRecordsOfRrsetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id_or_name = params.id_or_name;
    let rr_name = params.rr_name;
    let rr_type = params.rr_type;
    let update_records_of_rrset_request = params.update_records_of_rrset_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.cloud/v1");
    let local_var_uri_str = format!(
        "{}/zones/{id_or_name}/rrsets/{rr_name}/{rr_type}/actions/update_records",
        local_base_path,
        id_or_name = crate::apis::urlencode(id_or_name),
        rr_name = crate::apis::urlencode(rr_name),
        rr_type = crate::apis::urlencode(rr_type)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_records_of_rrset_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateRecordsOfRrsetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
