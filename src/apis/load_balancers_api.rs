/*
 * Hetzner Cloud API
 *
 * Copied from the official API documentation for the Public Hetzner Cloud.
 *
 * The version of the OpenAPI document: 0.0.3
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `add_service`
#[derive(Clone, Debug, Default)]
pub struct AddServiceParams {
    /// ID of the Load Balancer
    pub id: String,
    pub add_service_request: Option<crate::models::AddServiceRequest>
}

/// struct for passing parameters to the method `add_target`
#[derive(Clone, Debug, Default)]
pub struct AddTargetParams {
    /// ID of the Load Balancer
    pub id: String,
    pub add_target_request: Option<crate::models::AddTargetRequest>
}

/// struct for passing parameters to the method `attach_load_balancer_to_network`
#[derive(Clone, Debug, Default)]
pub struct AttachLoadBalancerToNetworkParams {
    /// ID of the Load Balancer
    pub id: String,
    pub attach_load_balancer_to_network_request: Option<crate::models::AttachLoadBalancerToNetworkRequest>
}

/// struct for passing parameters to the method `change_algorithm`
#[derive(Clone, Debug, Default)]
pub struct ChangeAlgorithmParams {
    /// ID of the Load Balancer
    pub id: String,
    pub change_algorithm_request: Option<crate::models::ChangeAlgorithmRequest>
}

/// struct for passing parameters to the method `change_load_balancer_protection`
#[derive(Clone, Debug, Default)]
pub struct ChangeLoadBalancerProtectionParams {
    /// ID of the Load Balancer
    pub id: String,
    pub change_load_balancer_protection_request: Option<crate::models::ChangeLoadBalancerProtectionRequest>
}

/// struct for passing parameters to the method `change_type_of_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct ChangeTypeOfLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String,
    pub change_type_of_load_balancer_request: Option<crate::models::ChangeTypeOfLoadBalancerRequest>
}

/// struct for passing parameters to the method `create_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct CreateLoadBalancerParams {
    pub create_load_balancer_request: Option<crate::models::CreateLoadBalancerRequest>
}

/// struct for passing parameters to the method `delete_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct DeleteLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String
}

/// struct for passing parameters to the method `delete_service`
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceParams {
    /// ID of the Load Balancer
    pub id: String,
    pub delete_service_request: Option<crate::models::DeleteServiceRequest>
}

/// struct for passing parameters to the method `detach_load_balancer_from_network`
#[derive(Clone, Debug, Default)]
pub struct DetachLoadBalancerFromNetworkParams {
    /// ID of the Load Balancer
    pub id: String,
    pub detach_load_balancer_from_network_request: Option<crate::models::DetachLoadBalancerFromNetworkRequest>
}

/// struct for passing parameters to the method `disable_public_interface_of_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct DisablePublicInterfaceOfLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String
}

/// struct for passing parameters to the method `enable_public_interface_of_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct EnablePublicInterfaceOfLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String
}

/// struct for passing parameters to the method `get_action_for_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct GetActionForLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String,
    /// ID of the Action
    pub action_id: String
}

/// struct for passing parameters to the method `get_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct GetLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String
}

/// struct for passing parameters to the method `get_metrics_for_loadbalancer`
#[derive(Clone, Debug, Default)]
pub struct GetMetricsForLoadbalancerParams {
    /// ID of the LoadBalancer
    pub id: String,
    /// Type of metrics to get open_connections requests_per_second bandwidth
    pub _type: String,
    /// Start of period to get Metrics for (in ISO-8601 format)
    pub start: String,
    /// End of period to get Metrics for (in ISO-8601 format)
    pub end: String,
    /// Resolution of results in seconds
    pub step: Option<String>
}

/// struct for passing parameters to the method `list_actions_for_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct ListActionsForLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String,
    /// Can be used multiple times, the response will contain only Actions with specified statuses Choices: running success error
    pub status: Option<String>,
    /// Can be used multiple times Choices: id id:asc id:desc command command:asc command:desc status status:asc status:desc progress progress:asc progress:desc started started:asc started:desc finished finished:asc finished:desc
    pub sort: Option<String>
}

/// struct for passing parameters to the method `list_load_balancers`
#[derive(Clone, Debug, Default)]
pub struct ListLoadBalancersParams {
    /// Can be used multiple times. Choices: id id:asc id:desc name name:asc name:desc created created:asc created:desc
    pub sort: Option<String>,
    /// Can be used to filter Load Balancers by their name. The response will only contain the Load Balancers matching the specified name.
    pub name: Option<String>,
    /// Can be used to filter Load Balancers by labels. The response will only contain Load Balancers with a matching label selector pattern.
    pub label_selector: Option<String>
}

/// struct for passing parameters to the method `remove_target`
#[derive(Clone, Debug, Default)]
pub struct RemoveTargetParams {
    /// ID of the Load Balancer
    pub id: String,
    pub remove_target_request: Option<crate::models::RemoveTargetRequest>
}

/// struct for passing parameters to the method `replace_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct ReplaceLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String,
    pub replace_load_balancer_request: Option<crate::models::ReplaceLoadBalancerRequest>
}

/// struct for passing parameters to the method `update_service`
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceParams {
    /// ID of the Load Balancer
    pub id: String,
    pub update_service_request: Option<crate::models::UpdateServiceRequest>
}


/// struct for typed errors of method `add_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `add_target`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddTargetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `attach_load_balancer_to_network`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttachLoadBalancerToNetworkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `change_algorithm`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeAlgorithmError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `change_load_balancer_protection`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeLoadBalancerProtectionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `change_type_of_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeTypeOfLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `detach_load_balancer_from_network`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DetachLoadBalancerFromNetworkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `disable_public_interface_of_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DisablePublicInterfaceOfLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `enable_public_interface_of_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnablePublicInterfaceOfLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_action_for_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActionForLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_metrics_for_loadbalancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMetricsForLoadbalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_actions_for_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListActionsForLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_load_balancers`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListLoadBalancersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `remove_target`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveTargetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `replace_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceError {
    UnknownValue(serde_json::Value),
}


/// Adds a service to a Load Balancer.
pub async fn add_service(configuration: &configuration::Configuration, params: AddServiceParams) -> Result<crate::models::AddServiceResponse, Error<AddServiceError>> {
    // unbox the parameters
    let id = params.id;
    let add_service_request = params.add_service_request;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/actions/add_service", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&add_service_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AddServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Adds a target to a Load Balancer.
pub async fn add_target(configuration: &configuration::Configuration, params: AddTargetParams) -> Result<crate::models::AddTargetResponse, Error<AddTargetError>> {
    // unbox the parameters
    let id = params.id;
    let add_target_request = params.add_target_request;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/actions/add_target", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&add_target_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AddTargetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Attach a Load Balancer to a Network.
pub async fn attach_load_balancer_to_network(configuration: &configuration::Configuration, params: AttachLoadBalancerToNetworkParams) -> Result<crate::models::AttachLoadBalancerToNetworkResponse, Error<AttachLoadBalancerToNetworkError>> {
    // unbox the parameters
    let id = params.id;
    let attach_load_balancer_to_network_request = params.attach_load_balancer_to_network_request;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/actions/attach_to_network", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&attach_load_balancer_to_network_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AttachLoadBalancerToNetworkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Change the algorithm that determines to which target new requests are sent.
pub async fn change_algorithm(configuration: &configuration::Configuration, params: ChangeAlgorithmParams) -> Result<crate::models::ChangeAlgorithmResponse, Error<ChangeAlgorithmError>> {
    // unbox the parameters
    let id = params.id;
    let change_algorithm_request = params.change_algorithm_request;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/actions/change_algorithm", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&change_algorithm_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChangeAlgorithmError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Changes the protection configuration of a Load Balancer.
pub async fn change_load_balancer_protection(configuration: &configuration::Configuration, params: ChangeLoadBalancerProtectionParams) -> Result<crate::models::ChangeLoadBalancerProtectionResponse, Error<ChangeLoadBalancerProtectionError>> {
    // unbox the parameters
    let id = params.id;
    let change_load_balancer_protection_request = params.change_load_balancer_protection_request;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/actions/change_protection", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&change_load_balancer_protection_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChangeLoadBalancerProtectionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Changes the type (Max Services, Max Targets and Max Connections) of a Load Balancer.
pub async fn change_type_of_load_balancer(configuration: &configuration::Configuration, params: ChangeTypeOfLoadBalancerParams) -> Result<crate::models::ChangeTypeOfLoadBalancerResponse, Error<ChangeTypeOfLoadBalancerError>> {
    // unbox the parameters
    let id = params.id;
    let change_type_of_load_balancer_request = params.change_type_of_load_balancer_request;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/actions/change_type", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&change_type_of_load_balancer_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChangeTypeOfLoadBalancerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a Load Balancer.
pub async fn create_load_balancer(configuration: &configuration::Configuration, params: CreateLoadBalancerParams) -> Result<crate::models::CreateLoadBalancerResponse, Error<CreateLoadBalancerError>> {
    // unbox the parameters
    let create_load_balancer_request = params.create_load_balancer_request;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_load_balancer_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateLoadBalancerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a Load Balancer.
pub async fn delete_load_balancer(configuration: &configuration::Configuration, params: DeleteLoadBalancerParams) -> Result<(), Error<DeleteLoadBalancerError>> {
    // unbox the parameters
    let id = params.id;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteLoadBalancerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a service of a Load Balancer.
pub async fn delete_service(configuration: &configuration::Configuration, params: DeleteServiceParams) -> Result<crate::models::DeleteServiceResponse, Error<DeleteServiceError>> {
    // unbox the parameters
    let id = params.id;
    let delete_service_request = params.delete_service_request;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/actions/delete_service", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&delete_service_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Detaches a Load Balancer from a network.
pub async fn detach_load_balancer_from_network(configuration: &configuration::Configuration, params: DetachLoadBalancerFromNetworkParams) -> Result<crate::models::DetachLoadBalancerFromNetworkResponse, Error<DetachLoadBalancerFromNetworkError>> {
    // unbox the parameters
    let id = params.id;
    let detach_load_balancer_from_network_request = params.detach_load_balancer_from_network_request;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/actions/detach_from_network", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&detach_load_balancer_from_network_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DetachLoadBalancerFromNetworkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Disable the public interface of a Load Balancer. The Load Balancer will be not accessible from the internet via its public IPs. The interface can only be disabled when all targets use the private IP.
pub async fn disable_public_interface_of_load_balancer(configuration: &configuration::Configuration, params: DisablePublicInterfaceOfLoadBalancerParams) -> Result<crate::models::DisablePublicInterfaceOfLoadBalancerResponse, Error<DisablePublicInterfaceOfLoadBalancerError>> {
    // unbox the parameters
    let id = params.id;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/actions/disable_public_interface", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DisablePublicInterfaceOfLoadBalancerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Enable the public interface of a Load Balancer. The Load Balancer will be accessible from the internet via its public IPs.
pub async fn enable_public_interface_of_load_balancer(configuration: &configuration::Configuration, params: EnablePublicInterfaceOfLoadBalancerParams) -> Result<crate::models::EnablePublicInterfaceOfLoadBalancerResponse, Error<EnablePublicInterfaceOfLoadBalancerError>> {
    // unbox the parameters
    let id = params.id;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/actions/enable_public_interface", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EnablePublicInterfaceOfLoadBalancerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a specific Action for a Load Balancer.
pub async fn get_action_for_load_balancer(configuration: &configuration::Configuration, params: GetActionForLoadBalancerParams) -> Result<crate::models::GetActionForLoadBalancerResponse, Error<GetActionForLoadBalancerError>> {
    // unbox the parameters
    let id = params.id;
    let action_id = params.action_id;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/actions/{action_id}", configuration.base_path, id=crate::apis::urlencode(id), action_id=crate::apis::urlencode(action_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetActionForLoadBalancerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a specific Load Balancer object.
pub async fn get_load_balancer(configuration: &configuration::Configuration, params: GetLoadBalancerParams) -> Result<crate::models::GetLoadBalancerResponse, Error<GetLoadBalancerError>> {
    // unbox the parameters
    let id = params.id;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetLoadBalancerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get Metrics for a LoadBalancer. You must specify the type of metric to get: open_connections, requests_per_second or bandwidth. You can also specify more than one type by comma separation, e.g. requests_per_second,bandwidth. Depending on the type you will get different time series data:
pub async fn get_metrics_for_loadbalancer(configuration: &configuration::Configuration, params: GetMetricsForLoadbalancerParams) -> Result<crate::models::GetMetricsForLoadbalancerResponse, Error<GetMetricsForLoadbalancerError>> {
    // unbox the parameters
    let id = params.id;
    let _type = params._type;
    let start = params.start;
    let end = params.end;
    let step = params.step;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/metrics", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("type", &_type.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("start", &start.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("end", &end.to_string())]);
    if let Some(ref local_var_str) = step {
        local_var_req_builder = local_var_req_builder.query(&[("step", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetMetricsForLoadbalancerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all Action objects for a Load Balancer. You can sort the results by using the sort URI parameter, and filter them with the status parameter.
pub async fn list_actions_for_load_balancer(configuration: &configuration::Configuration, params: ListActionsForLoadBalancerParams) -> Result<crate::models::ListActionsForLoadBalancerResponse, Error<ListActionsForLoadBalancerError>> {
    // unbox the parameters
    let id = params.id;
    let status = params.status;
    let sort = params.sort;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/actions", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListActionsForLoadBalancerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets all existing Load Balancers that you have available.
pub async fn list_load_balancers(configuration: &configuration::Configuration, params: ListLoadBalancersParams) -> Result<crate::models::ListLoadBalancersResponse, Error<ListLoadBalancersError>> {
    // unbox the parameters
    let sort = params.sort;
    let name = params.name;
    let label_selector = params.label_selector;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sort {
        local_var_req_builder = local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name {
        local_var_req_builder = local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = label_selector {
        local_var_req_builder = local_var_req_builder.query(&[("label_selector", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListLoadBalancersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes a target from a Load Balancer.
pub async fn remove_target(configuration: &configuration::Configuration, params: RemoveTargetParams) -> Result<crate::models::RemoveTargetResponse, Error<RemoveTargetError>> {
    // unbox the parameters
    let id = params.id;
    let remove_target_request = params.remove_target_request;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/actions/remove_target", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&remove_target_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RemoveTargetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a Load Balancer. You can update a Load Balancer’s name and a Load Balancer’s labels. Note that when updating labels, the Load Balancer’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body. Note: if the Load Balancer object changes during the request, the response will be a “conflict” error.
pub async fn replace_load_balancer(configuration: &configuration::Configuration, params: ReplaceLoadBalancerParams) -> Result<crate::models::ReplaceLoadBalancerResponse, Error<ReplaceLoadBalancerError>> {
    // unbox the parameters
    let id = params.id;
    let replace_load_balancer_request = params.replace_load_balancer_request;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&replace_load_balancer_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReplaceLoadBalancerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a Load Balancer Service.
pub async fn update_service(configuration: &configuration::Configuration, params: UpdateServiceParams) -> Result<crate::models::UpdateServiceResponse, Error<UpdateServiceError>> {
    // unbox the parameters
    let id = params.id;
    let update_service_request = params.update_service_request;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/load_balancers/{id}/actions/update_service", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_service_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

