/*
 * Hetzner Cloud API
 *
 * Copied from the official API documentation for the Public Hetzner Cloud.
 *
 * The version of the OpenAPI document: 0.0.3
 * 
 * Generated by: https://openapi-generator.tech
 */

#[allow(unused_imports)]
use std::rc::Rc;

use std::option::Option;

use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `add_service`
#[derive(Clone, Debug, Default)]
pub struct AddServiceParams {
    /// ID of the Load Balancer
    pub id: String,
    pub add_service_request: Option<crate::models::AddServiceRequest>
}

/// struct for passing parameters to the method `add_target`
#[derive(Clone, Debug, Default)]
pub struct AddTargetParams {
    /// ID of the Load Balancer
    pub id: String,
    pub add_target_request: Option<crate::models::AddTargetRequest>
}

/// struct for passing parameters to the method `attach_load_balancer_to_network`
#[derive(Clone, Debug, Default)]
pub struct AttachLoadBalancerToNetworkParams {
    /// ID of the Load Balancer
    pub id: String,
    pub attach_load_balancer_to_network_request: Option<crate::models::AttachLoadBalancerToNetworkRequest>
}

/// struct for passing parameters to the method `change_algorithm`
#[derive(Clone, Debug, Default)]
pub struct ChangeAlgorithmParams {
    /// ID of the Load Balancer
    pub id: String,
    pub change_algorithm_request: Option<crate::models::ChangeAlgorithmRequest>
}

/// struct for passing parameters to the method `change_load_balancer_protection`
#[derive(Clone, Debug, Default)]
pub struct ChangeLoadBalancerProtectionParams {
    /// ID of the Load Balancer
    pub id: String,
    pub change_load_balancer_protection_request: Option<crate::models::ChangeLoadBalancerProtectionRequest>
}

/// struct for passing parameters to the method `change_type_of_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct ChangeTypeOfLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String,
    pub change_type_of_load_balancer_request: Option<crate::models::ChangeTypeOfLoadBalancerRequest>
}

/// struct for passing parameters to the method `create_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct CreateLoadBalancerParams {
    pub create_load_balancer_request: Option<crate::models::CreateLoadBalancerRequest>
}

/// struct for passing parameters to the method `delete_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct DeleteLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String
}

/// struct for passing parameters to the method `delete_service`
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceParams {
    /// ID of the Load Balancer
    pub id: String,
    pub delete_service_request: Option<crate::models::DeleteServiceRequest>
}

/// struct for passing parameters to the method `detach_load_balancer_from_network`
#[derive(Clone, Debug, Default)]
pub struct DetachLoadBalancerFromNetworkParams {
    /// ID of the Load Balancer
    pub id: String,
    pub detach_load_balancer_from_network_request: Option<crate::models::DetachLoadBalancerFromNetworkRequest>
}

/// struct for passing parameters to the method `disable_public_interface_of_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct DisablePublicInterfaceOfLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String
}

/// struct for passing parameters to the method `enable_public_interface_of_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct EnablePublicInterfaceOfLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String
}

/// struct for passing parameters to the method `get_action_for_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct GetActionForLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String,
    /// ID of the Action
    pub action_id: String
}

/// struct for passing parameters to the method `get_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct GetLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String
}

/// struct for passing parameters to the method `get_metrics_for_loadbalancer`
#[derive(Clone, Debug, Default)]
pub struct GetMetricsForLoadbalancerParams {
    /// ID of the LoadBalancer
    pub id: String,
    /// Type of metrics to get open_connections requests_per_second bandwidth
    pub _type: String,
    /// Start of period to get Metrics for (in ISO-8601 format)
    pub start: String,
    /// End of period to get Metrics for (in ISO-8601 format)
    pub end: String,
    /// Resolution of results in seconds
    pub step: Option<String>
}

/// struct for passing parameters to the method `list_actions_for_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct ListActionsForLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String,
    /// Can be used multiple times, the response will contain only Actions with specified statuses Choices: running success error
    pub status: Option<String>,
    /// Can be used multiple times Choices: id id:asc id:desc command command:asc command:desc status status:asc status:desc progress progress:asc progress:desc started started:asc started:desc finished finished:asc finished:desc
    pub sort: Option<String>
}

/// struct for passing parameters to the method `list_load_balancers`
#[derive(Clone, Debug, Default)]
pub struct ListLoadBalancersParams {
    /// Can be used multiple times. Choices: id id:asc id:desc name name:asc name:desc created created:asc created:desc
    pub sort: Option<String>,
    /// Can be used to filter Load Balancers by their name. The response will only contain the Load Balancers matching the specified name.
    pub name: Option<String>,
    /// Can be used to filter Load Balancers by labels. The response will only contain Load Balancers with a matching label selector pattern.
    pub label_selector: Option<String>
}

/// struct for passing parameters to the method `remove_target`
#[derive(Clone, Debug, Default)]
pub struct RemoveTargetParams {
    /// ID of the Load Balancer
    pub id: String,
    pub remove_target_request: Option<crate::models::RemoveTargetRequest>
}

/// struct for passing parameters to the method `replace_load_balancer`
#[derive(Clone, Debug, Default)]
pub struct ReplaceLoadBalancerParams {
    /// ID of the Load Balancer
    pub id: String,
    pub replace_load_balancer_request: Option<crate::models::ReplaceLoadBalancerRequest>
}

/// struct for passing parameters to the method `update_service`
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceParams {
    /// ID of the Load Balancer
    pub id: String,
    pub update_service_request: Option<crate::models::UpdateServiceRequest>
}


/// struct for typed errors of method `add_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `add_target`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddTargetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `attach_load_balancer_to_network`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttachLoadBalancerToNetworkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `change_algorithm`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeAlgorithmError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `change_load_balancer_protection`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeLoadBalancerProtectionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `change_type_of_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeTypeOfLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `detach_load_balancer_from_network`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DetachLoadBalancerFromNetworkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `disable_public_interface_of_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DisablePublicInterfaceOfLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `enable_public_interface_of_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnablePublicInterfaceOfLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_action_for_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActionForLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_metrics_for_loadbalancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMetricsForLoadbalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_actions_for_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListActionsForLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_load_balancers`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListLoadBalancersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `remove_target`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveTargetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `replace_load_balancer`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceLoadBalancerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceError {
    UnknownValue(serde_json::Value),
}


    pub async fn add_service(configuration: &configuration::Configuration, params: AddServiceParams) -> Result<crate::models::AddServiceResponse, Error<AddServiceError>> {
        // unbox the parameters
        let id = params.id;
        let add_service_request = params.add_service_request;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/actions/add_service", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&add_service_request);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<AddServiceError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn add_target(configuration: &configuration::Configuration, params: AddTargetParams) -> Result<crate::models::AddTargetResponse, Error<AddTargetError>> {
        // unbox the parameters
        let id = params.id;
        let add_target_request = params.add_target_request;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/actions/add_target", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&add_target_request);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<AddTargetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn attach_load_balancer_to_network(configuration: &configuration::Configuration, params: AttachLoadBalancerToNetworkParams) -> Result<crate::models::AttachLoadBalancerToNetworkResponse, Error<AttachLoadBalancerToNetworkError>> {
        // unbox the parameters
        let id = params.id;
        let attach_load_balancer_to_network_request = params.attach_load_balancer_to_network_request;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/actions/attach_to_network", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&attach_load_balancer_to_network_request);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<AttachLoadBalancerToNetworkError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn change_algorithm(configuration: &configuration::Configuration, params: ChangeAlgorithmParams) -> Result<crate::models::ChangeAlgorithmResponse, Error<ChangeAlgorithmError>> {
        // unbox the parameters
        let id = params.id;
        let change_algorithm_request = params.change_algorithm_request;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/actions/change_algorithm", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&change_algorithm_request);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChangeAlgorithmError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn change_load_balancer_protection(configuration: &configuration::Configuration, params: ChangeLoadBalancerProtectionParams) -> Result<crate::models::ChangeLoadBalancerProtectionResponse, Error<ChangeLoadBalancerProtectionError>> {
        // unbox the parameters
        let id = params.id;
        let change_load_balancer_protection_request = params.change_load_balancer_protection_request;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/actions/change_protection", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&change_load_balancer_protection_request);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChangeLoadBalancerProtectionError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn change_type_of_load_balancer(configuration: &configuration::Configuration, params: ChangeTypeOfLoadBalancerParams) -> Result<crate::models::ChangeTypeOfLoadBalancerResponse, Error<ChangeTypeOfLoadBalancerError>> {
        // unbox the parameters
        let id = params.id;
        let change_type_of_load_balancer_request = params.change_type_of_load_balancer_request;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/actions/change_type", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&change_type_of_load_balancer_request);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChangeTypeOfLoadBalancerError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn create_load_balancer(configuration: &configuration::Configuration, params: CreateLoadBalancerParams) -> Result<crate::models::CreateLoadBalancerResponse, Error<CreateLoadBalancerError>> {
        // unbox the parameters
        let create_load_balancer_request = params.create_load_balancer_request;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&create_load_balancer_request);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<CreateLoadBalancerError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn delete_load_balancer(configuration: &configuration::Configuration, params: DeleteLoadBalancerParams) -> Result<(), Error<DeleteLoadBalancerError>> {
        // unbox the parameters
        let id = params.id;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            Ok(())
        } else {
            let entity: Option<DeleteLoadBalancerError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn delete_service(configuration: &configuration::Configuration, params: DeleteServiceParams) -> Result<crate::models::DeleteServiceResponse, Error<DeleteServiceError>> {
        // unbox the parameters
        let id = params.id;
        let delete_service_request = params.delete_service_request;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/actions/delete_service", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&delete_service_request);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<DeleteServiceError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn detach_load_balancer_from_network(configuration: &configuration::Configuration, params: DetachLoadBalancerFromNetworkParams) -> Result<crate::models::DetachLoadBalancerFromNetworkResponse, Error<DetachLoadBalancerFromNetworkError>> {
        // unbox the parameters
        let id = params.id;
        let detach_load_balancer_from_network_request = params.detach_load_balancer_from_network_request;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/actions/detach_from_network", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&detach_load_balancer_from_network_request);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<DetachLoadBalancerFromNetworkError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn disable_public_interface_of_load_balancer(configuration: &configuration::Configuration, params: DisablePublicInterfaceOfLoadBalancerParams) -> Result<crate::models::DisablePublicInterfaceOfLoadBalancerResponse, Error<DisablePublicInterfaceOfLoadBalancerError>> {
        // unbox the parameters
        let id = params.id;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/actions/disable_public_interface", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<DisablePublicInterfaceOfLoadBalancerError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn enable_public_interface_of_load_balancer(configuration: &configuration::Configuration, params: EnablePublicInterfaceOfLoadBalancerParams) -> Result<crate::models::EnablePublicInterfaceOfLoadBalancerResponse, Error<EnablePublicInterfaceOfLoadBalancerError>> {
        // unbox the parameters
        let id = params.id;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/actions/enable_public_interface", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<EnablePublicInterfaceOfLoadBalancerError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn get_action_for_load_balancer(configuration: &configuration::Configuration, params: GetActionForLoadBalancerParams) -> Result<crate::models::GetActionForLoadBalancerResponse, Error<GetActionForLoadBalancerError>> {
        // unbox the parameters
        let id = params.id;
        let action_id = params.action_id;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/actions/{action_id}", configuration.base_path, id=crate::apis::urlencode(id), action_id=crate::apis::urlencode(action_id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<GetActionForLoadBalancerError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn get_load_balancer(configuration: &configuration::Configuration, params: GetLoadBalancerParams) -> Result<crate::models::GetLoadBalancerResponse, Error<GetLoadBalancerError>> {
        // unbox the parameters
        let id = params.id;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<GetLoadBalancerError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn get_metrics_for_loadbalancer(configuration: &configuration::Configuration, params: GetMetricsForLoadbalancerParams) -> Result<crate::models::GetMetricsForLoadbalancerResponse, Error<GetMetricsForLoadbalancerError>> {
        // unbox the parameters
        let id = params.id;
        let _type = params._type;
        let start = params.start;
        let end = params.end;
        let step = params.step;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/metrics", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.get(uri_str.as_str());

        req_builder = req_builder.query(&[("type", &_type.to_string())]);
        req_builder = req_builder.query(&[("start", &start.to_string())]);
        req_builder = req_builder.query(&[("end", &end.to_string())]);
        if let Some(ref s) = step {
            req_builder = req_builder.query(&[("step", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<GetMetricsForLoadbalancerError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn list_actions_for_load_balancer(configuration: &configuration::Configuration, params: ListActionsForLoadBalancerParams) -> Result<crate::models::ListActionsForLoadBalancerResponse, Error<ListActionsForLoadBalancerError>> {
        // unbox the parameters
        let id = params.id;
        let status = params.status;
        let sort = params.sort;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/actions", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = status {
            req_builder = req_builder.query(&[("status", &s.to_string())]);
        }
        if let Some(ref s) = sort {
            req_builder = req_builder.query(&[("sort", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ListActionsForLoadBalancerError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn list_load_balancers(configuration: &configuration::Configuration, params: ListLoadBalancersParams) -> Result<crate::models::ListLoadBalancersResponse, Error<ListLoadBalancersError>> {
        // unbox the parameters
        let sort = params.sort;
        let name = params.name;
        let label_selector = params.label_selector;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = sort {
            req_builder = req_builder.query(&[("sort", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = label_selector {
            req_builder = req_builder.query(&[("label_selector", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ListLoadBalancersError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn remove_target(configuration: &configuration::Configuration, params: RemoveTargetParams) -> Result<crate::models::RemoveTargetResponse, Error<RemoveTargetError>> {
        // unbox the parameters
        let id = params.id;
        let remove_target_request = params.remove_target_request;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/actions/remove_target", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&remove_target_request);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<RemoveTargetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn replace_load_balancer(configuration: &configuration::Configuration, params: ReplaceLoadBalancerParams) -> Result<crate::models::ReplaceLoadBalancerResponse, Error<ReplaceLoadBalancerError>> {
        // unbox the parameters
        let id = params.id;
        let replace_load_balancer_request = params.replace_load_balancer_request;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&replace_load_balancer_request);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ReplaceLoadBalancerError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn update_service(configuration: &configuration::Configuration, params: UpdateServiceParams) -> Result<crate::models::UpdateServiceResponse, Error<UpdateServiceError>> {
        // unbox the parameters
        let id = params.id;
        let update_service_request = params.update_service_request;

        let client = &configuration.client;

        let uri_str = format!("{}/load_balancers/{id}/actions/update_service", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&update_service_request);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<UpdateServiceError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

