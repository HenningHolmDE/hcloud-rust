/*
 * Hetzner Cloud API
 *
 * Copied from the official API documentation for the Public Hetzner Cloud.
 *
 * The version of the OpenAPI document: 0.0.3
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `create_certificate`
#[derive(Clone, Debug, Default)]
pub struct CreateCertificateParams {
    pub create_certificate_request: Option<crate::models::CreateCertificateRequest>
}

/// struct for passing parameters to the method `delete_certificate`
#[derive(Clone, Debug, Default)]
pub struct DeleteCertificateParams {
    /// ID of the Certificate
    pub id: String
}

/// struct for passing parameters to the method `get_certificate`
#[derive(Clone, Debug, Default)]
pub struct GetCertificateParams {
    /// ID of the Certificate
    pub id: String
}

/// struct for passing parameters to the method `list_certificates`
#[derive(Clone, Debug, Default)]
pub struct ListCertificatesParams {
    /// Can be used multiple times. Choices: id id:asc id:desc name name:asc name:desc created created:asc created:desc
    pub sort: Option<String>,
    /// Can be used to filter Certificates by their name. The response will only contain the Certificates matching the specified name.
    pub name: Option<String>,
    /// Can be used to filter Certificates by labels. The response will only contain Certificates with a matching label selector pattern.
    pub label_selector: Option<String>
}

/// struct for passing parameters to the method `replace_certificate`
#[derive(Clone, Debug, Default)]
pub struct ReplaceCertificateParams {
    /// ID of the Certificate to update
    pub id: String,
    pub replace_certificate_request: Option<crate::models::ReplaceCertificateRequest>
}


/// struct for typed errors of method `create_certificate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCertificateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_certificate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCertificateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_certificate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCertificateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_certificates`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCertificatesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `replace_certificate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceCertificateError {
    UnknownValue(serde_json::Value),
}


/// Creates a new Certificate.
pub async fn create_certificate(configuration: &configuration::Configuration, params: CreateCertificateParams) -> Result<crate::models::CreateCertificateResponse, Error<CreateCertificateError>> {
    // unbox the parameters
    let create_certificate_request = params.create_certificate_request;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_certificate_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateCertificateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a Certificate.
pub async fn delete_certificate(configuration: &configuration::Configuration, params: DeleteCertificateParams) -> Result<(), Error<DeleteCertificateError>> {
    // unbox the parameters
    let id = params.id;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{id}", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteCertificateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a specific Certificate object.
pub async fn get_certificate(configuration: &configuration::Configuration, params: GetCertificateParams) -> Result<crate::models::GetCertificateResponse, Error<GetCertificateError>> {
    // unbox the parameters
    let id = params.id;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{id}", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCertificateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all Certificate objects.
pub async fn list_certificates(configuration: &configuration::Configuration, params: ListCertificatesParams) -> Result<crate::models::ListCertificatesResponse, Error<ListCertificatesError>> {
    // unbox the parameters
    let sort = params.sort;
    let name = params.name;
    let label_selector = params.label_selector;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sort {
        local_var_req_builder = local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name {
        local_var_req_builder = local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = label_selector {
        local_var_req_builder = local_var_req_builder.query(&[("label_selector", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListCertificatesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates the Certificate properties. Note that when updating labels, the Certificate’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body. Note: if the Certificate object changes during the request, the response will be a “conflict” error.
pub async fn replace_certificate(configuration: &configuration::Configuration, params: ReplaceCertificateParams) -> Result<crate::models::ReplaceCertificateResponse, Error<ReplaceCertificateError>> {
    // unbox the parameters
    let id = params.id;
    let replace_certificate_request = params.replace_certificate_request;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/certificates/{id}", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&replace_certificate_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReplaceCertificateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

