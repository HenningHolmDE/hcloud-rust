/*
 * Hetzner Cloud API
 *
 * Copied from the official API documentation for the Public Hetzner Cloud.
 *
 * The version of the OpenAPI document: 0.28.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};

/// struct for passing parameters to the method [`change_home_directory`]
#[derive(Clone, Debug, Default)]
pub struct ChangeHomeDirectoryParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Subaccount.
    pub subaccount_id: i64,
    pub change_home_directory_request: models::ChangeHomeDirectoryRequest,
}

/// struct for passing parameters to the method [`change_protection`]
#[derive(Clone, Debug, Default)]
pub struct ChangeProtectionParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub change_protection_request: models::ChangeProtectionRequest,
}

/// struct for passing parameters to the method [`change_type`]
#[derive(Clone, Debug, Default)]
pub struct ChangeTypeParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub change_type_request: models::ChangeTypeRequest,
}

/// struct for passing parameters to the method [`create_snapshot`]
#[derive(Clone, Debug, Default)]
pub struct CreateSnapshotParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub create_snapshot_request: models::CreateSnapshotRequest,
}

/// struct for passing parameters to the method [`create_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct CreateStorageBoxParams {
    pub create_storage_box_request: models::CreateStorageBoxRequest,
}

/// struct for passing parameters to the method [`create_subaccount`]
#[derive(Clone, Debug, Default)]
pub struct CreateSubaccountParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub create_subaccount_request: models::CreateSubaccountRequest,
}

/// struct for passing parameters to the method [`delete_snapshot`]
#[derive(Clone, Debug, Default)]
pub struct DeleteSnapshotParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Snapshot.
    pub snapshot_id: i64,
}

/// struct for passing parameters to the method [`delete_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct DeleteStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
}

/// struct for passing parameters to the method [`delete_subaccount`]
#[derive(Clone, Debug, Default)]
pub struct DeleteSubaccountParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Subaccount.
    pub subaccount_id: i64,
}

/// struct for passing parameters to the method [`disable_snapshot_plan`]
#[derive(Clone, Debug, Default)]
pub struct DisableSnapshotPlanParams {
    /// ID of the Storage Box.
    pub id: i64,
}

/// struct for passing parameters to the method [`enable_snapshot_plan`]
#[derive(Clone, Debug, Default)]
pub struct EnableSnapshotPlanParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub enable_snapshot_plan_request: models::EnableSnapshotPlanRequest,
}

/// struct for passing parameters to the method [`get_action_for_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct GetActionForStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Action.
    pub action_id: i64,
}

/// struct for passing parameters to the method [`get_snapshot`]
#[derive(Clone, Debug, Default)]
pub struct GetSnapshotParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Snapshot.
    pub snapshot_id: i64,
}

/// struct for passing parameters to the method [`get_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct GetStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
}

/// struct for passing parameters to the method [`get_storage_box_action`]
#[derive(Clone, Debug, Default)]
pub struct GetStorageBoxActionParams {
    /// ID of the Action.
    pub id: i64,
}

/// struct for passing parameters to the method [`get_subaccount`]
#[derive(Clone, Debug, Default)]
pub struct GetSubaccountParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Subaccount.
    pub subaccount_id: i64,
}

/// struct for passing parameters to the method [`list_actions_for_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct ListActionsForStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// Sort actions by field and direction. Can be used multiple times. For more information, see \"Sorting\".
    pub sort: Option<Vec<String>>,
    /// Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.
    pub status: Option<Vec<String>>,
    /// Page number to return. For more information, see \"Pagination\".
    pub page: Option<i64>,
    /// Maximum number of entries returned per page. For more information, see \"Pagination\".
    pub per_page: Option<i64>,
}

/// struct for passing parameters to the method [`list_folders_of_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct ListFoldersOfStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// Relative path for which the listing is to be made.
    pub path: Option<String>,
}

/// struct for passing parameters to the method [`list_snapshots`]
#[derive(Clone, Debug, Default)]
pub struct ListSnapshotsParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// Filter resources by their name. The response will only contain the resources matching exactly the specified name.
    pub name: Option<String>,
    /// Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \"Label Selector\".
    pub label_selector: Option<String>,
    /// Sort resources by field and direction. Can be used multiple times. For more information, see \"Sorting\".
    pub sort: Option<Vec<String>>,
    /// Filter wether a Storage Box Snapshot is automatic.
    pub is_automatic: Option<bool>,
}

/// struct for passing parameters to the method [`list_storage_box_actions`]
#[derive(Clone, Debug, Default)]
pub struct ListStorageBoxActionsParams {
    /// Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.
    pub id: Option<Vec<i64>>,
    /// Sort actions by field and direction. Can be used multiple times. For more information, see \"Sorting\".
    pub sort: Option<Vec<String>>,
    /// Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.
    pub status: Option<Vec<String>>,
    /// Page number to return. For more information, see \"Pagination\".
    pub page: Option<i64>,
    /// Maximum number of entries returned per page. For more information, see \"Pagination\".
    pub per_page: Option<i64>,
}

/// struct for passing parameters to the method [`list_storage_boxes`]
#[derive(Clone, Debug, Default)]
pub struct ListStorageBoxesParams {
    /// Filter resources by their name. The response will only contain the resources matching exactly the specified name.
    pub name: Option<String>,
    /// Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \"Label Selector\".
    pub label_selector: Option<String>,
    /// Sort resources by field and direction. Can be used multiple times. For more information, see \"Sorting\".
    pub sort: Option<Vec<String>>,
    /// Page number to return. For more information, see \"Pagination\".
    pub page: Option<i64>,
    /// Maximum number of entries returned per page. For more information, see \"Pagination\".
    pub per_page: Option<i64>,
}

/// struct for passing parameters to the method [`list_subaccounts`]
#[derive(Clone, Debug, Default)]
pub struct ListSubaccountsParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \"Label Selector\".
    pub label_selector: Option<String>,
    /// Sort resources by field and direction. Can be used multiple times. For more information, see \"Sorting\".
    pub sort: Option<Vec<String>>,
    /// Filter Storage Box Subaccounts by username. The response will only contain the resources matching exactly the specified username.
    pub username: Option<String>,
}

/// struct for passing parameters to the method [`replace_snapshot`]
#[derive(Clone, Debug, Default)]
pub struct ReplaceSnapshotParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Snapshot.
    pub snapshot_id: i64,
    pub replace_snapshot_request: models::ReplaceSnapshotRequest,
}

/// struct for passing parameters to the method [`replace_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct ReplaceStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub replace_storage_box_request: models::ReplaceStorageBoxRequest,
}

/// struct for passing parameters to the method [`replace_subaccount`]
#[derive(Clone, Debug, Default)]
pub struct ReplaceSubaccountParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Subaccount.
    pub subaccount_id: i64,
    pub replace_subaccount_request: models::ReplaceSubaccountRequest,
}

/// struct for passing parameters to the method [`reset_storage_box_password`]
#[derive(Clone, Debug, Default)]
pub struct ResetStorageBoxPasswordParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub reset_password_request: models::ResetPasswordRequest,
}

/// struct for passing parameters to the method [`reset_storage_box_subaccount_password`]
#[derive(Clone, Debug, Default)]
pub struct ResetStorageBoxSubaccountPasswordParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Subaccount.
    pub subaccount_id: i64,
    pub reset_password_request: models::ResetPasswordRequest,
}

/// struct for passing parameters to the method [`rollback_snapshot`]
#[derive(Clone, Debug, Default)]
pub struct RollbackSnapshotParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub rollback_snapshot_request: models::RollbackSnapshotRequest,
}

/// struct for passing parameters to the method [`update_storage_box_access_settings`]
#[derive(Clone, Debug, Default)]
pub struct UpdateStorageBoxAccessSettingsParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub update_access_settings_request: models::UpdateAccessSettingsRequest,
}

/// struct for passing parameters to the method [`update_storage_box_subaccount_access_settings`]
#[derive(Clone, Debug, Default)]
pub struct UpdateStorageBoxSubaccountAccessSettingsParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Subaccount.
    pub subaccount_id: i64,
    pub update_access_settings_request: models::UpdateAccessSettingsRequest,
}

/// struct for typed errors of method [`change_home_directory`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeHomeDirectoryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_protection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeProtectionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_snapshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSnapshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_subaccount`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSubaccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_snapshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSnapshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_subaccount`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSubaccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`disable_snapshot_plan`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DisableSnapshotPlanError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enable_snapshot_plan`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnableSnapshotPlanError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_action_for_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActionForStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_snapshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSnapshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_storage_box_action`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStorageBoxActionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_subaccount`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubaccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_actions_for_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListActionsForStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_folders_of_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFoldersOfStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_snapshots`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSnapshotsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_storage_box_actions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListStorageBoxActionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_storage_boxes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListStorageBoxesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_subaccounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSubaccountsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`replace_snapshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceSnapshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`replace_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`replace_subaccount`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceSubaccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_storage_box_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetStorageBoxPasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_storage_box_subaccount_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetStorageBoxSubaccountPasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rollback_snapshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RollbackSnapshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_storage_box_access_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateStorageBoxAccessSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_storage_box_subaccount_access_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateStorageBoxSubaccountAccessSettingsError {
    UnknownValue(serde_json::Value),
}

/// Change the home directory of a Storage Box Subaccount.
pub async fn change_home_directory(
    configuration: &configuration::Configuration,
    params: ChangeHomeDirectoryParams,
) -> Result<models::ChangeHomeDirectoryResponse, Error<ChangeHomeDirectoryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let subaccount_id = params.subaccount_id;
    let change_home_directory_request = params.change_home_directory_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts/{subaccount_id}/actions/change_home_directory",
        local_base_path,
        id = id,
        subaccount_id = subaccount_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&change_home_directory_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChangeHomeDirectoryError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Changes the protection configuration of a Storage Box.
pub async fn change_protection(
    configuration: &configuration::Configuration,
    params: ChangeProtectionParams,
) -> Result<models::ChangeProtectionResponse, Error<ChangeProtectionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let change_protection_request = params.change_protection_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/change_protection",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&change_protection_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChangeProtectionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Changes the type of a Storage Box.  Upgrades or downgrades a Storage Box to another Storage Box Type.  It is not possible to downgrade to a Storage Box Type that offers less disk space than you are currently using.
pub async fn change_type(
    configuration: &configuration::Configuration,
    params: ChangeTypeParams,
) -> Result<models::ChangeTypeResponse, Error<ChangeTypeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let change_type_request = params.change_type_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/change_type",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&change_type_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChangeTypeError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a Storage Box Snapshot.
pub async fn create_snapshot(
    configuration: &configuration::Configuration,
    params: CreateSnapshotParams,
) -> Result<models::CreateSnapshotResponse, Error<CreateSnapshotError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let create_snapshot_request = params.create_snapshot_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/{id}/snapshots", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_snapshot_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateSnapshotError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a Storage Box.
pub async fn create_storage_box(
    configuration: &configuration::Configuration,
    params: CreateStorageBoxParams,
) -> Result<models::CreateStorageBoxResponse, Error<CreateStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let create_storage_box_request = params.create_storage_box_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes", local_base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_storage_box_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a Storage Box Subaccount.  A Storage Box Subaccount will use a separate home directory.
pub async fn create_subaccount(
    configuration: &configuration::Configuration,
    params: CreateSubaccountParams,
) -> Result<models::CreateSubaccountResponse, Error<CreateSubaccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let create_subaccount_request = params.create_subaccount_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_subaccount_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateSubaccountError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a Storage Box Snapshot.
pub async fn delete_snapshot(
    configuration: &configuration::Configuration,
    params: DeleteSnapshotParams,
) -> Result<models::DeleteSnapshotResponse, Error<DeleteSnapshotError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let snapshot_id = params.snapshot_id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/snapshots/{snapshot_id}",
        local_base_path,
        id = id,
        snapshot_id = snapshot_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteSnapshotError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a Storage Box.
pub async fn delete_storage_box(
    configuration: &configuration::Configuration,
    params: DeleteStorageBoxParams,
) -> Result<models::DeleteStorageBoxResponse, Error<DeleteStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/{id}", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a Storage Box Subaccount.
pub async fn delete_subaccount(
    configuration: &configuration::Configuration,
    params: DeleteSubaccountParams,
) -> Result<models::DeleteSubaccountResponse, Error<DeleteSubaccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let subaccount_id = params.subaccount_id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts/{subaccount_id}",
        local_base_path,
        id = id,
        subaccount_id = subaccount_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteSubaccountError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Disables the active Snapshot Plan of a Storage Box.  Existing Storage Box Snapshots created by the Snapshot Plan will not be delete, they must be removed manually.
pub async fn disable_snapshot_plan(
    configuration: &configuration::Configuration,
    params: DisableSnapshotPlanParams,
) -> Result<models::DisableSnapshotPlanResponse, Error<DisableSnapshotPlanError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/disable_snapshot_plan",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DisableSnapshotPlanError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Enables a Snapshot Plan for a Storage Box.  Once enabled, a Snapshot Plan will create Snapshots at predefined intervals. There can only ever be one Snapshot Plan. The existing Snapshot Plan will be deleted before a new one is set up.  Automatic Snapshots are retained until explicitly deleted by the user or the maximum snapshot count for the plan (\"max_snapshots\") is exceeded.  You can choose the specific time (UTC timezone), day of the week, and day of the month. The time-related options are cron like. Some typical use cases include:  | Interval                                   | Request body                                                  | | ------------------------------------------ | ------------------------------------------------------------- | | Every day at 3 o'clock                     | `{\"max_snapshots\":10,\"minute\":0,\"hour\":3}`                    | | Every Friday at 3 o'clock                  | `{\"max_snapshots\":10,\"minute\":0,\"hour\":3,\"day_of_week\": 5}`   | | On the first of every month at half past 6 | `{\"max_snapshots\":10,\"minute\":30,\"hour\":6,\"day_of_month\": 1}` |
pub async fn enable_snapshot_plan(
    configuration: &configuration::Configuration,
    params: EnableSnapshotPlanParams,
) -> Result<models::EnableSnapshotPlanResponse, Error<EnableSnapshotPlanError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let enable_snapshot_plan_request = params.enable_snapshot_plan_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/enable_snapshot_plan",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&enable_snapshot_plan_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EnableSnapshotPlanError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a specific Action object for a Storage Box.
pub async fn get_action_for_storage_box(
    configuration: &configuration::Configuration,
    params: GetActionForStorageBoxParams,
) -> Result<models::GetActionResponse, Error<GetActionForStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let action_id = params.action_id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/{action_id}",
        local_base_path,
        id = id,
        action_id = action_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetActionForStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a specific Storage Box Snapshot.
pub async fn get_snapshot(
    configuration: &configuration::Configuration,
    params: GetSnapshotParams,
) -> Result<models::GetSnapshotResponse, Error<GetSnapshotError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let snapshot_id = params.snapshot_id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/snapshots/{snapshot_id}",
        local_base_path,
        id = id,
        snapshot_id = snapshot_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSnapshotError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a specific Storage Box.
pub async fn get_storage_box(
    configuration: &configuration::Configuration,
    params: GetStorageBoxParams,
) -> Result<models::GetStorageBoxResponse, Error<GetStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/{id}", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a specific Action object.
pub async fn get_storage_box_action(
    configuration: &configuration::Configuration,
    params: GetStorageBoxActionParams,
) -> Result<models::GetActionResponse, Error<GetStorageBoxActionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/actions/{id}", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetStorageBoxActionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a specific Storage Box Subaccount.
pub async fn get_subaccount(
    configuration: &configuration::Configuration,
    params: GetSubaccountParams,
) -> Result<models::GetSubaccountResponse, Error<GetSubaccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let subaccount_id = params.subaccount_id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts/{subaccount_id}",
        local_base_path,
        id = id,
        subaccount_id = subaccount_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSubaccountError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all Actions related to a specific Storage Box.
pub async fn list_actions_for_storage_box(
    configuration: &configuration::Configuration,
    params: ListActionsForStorageBoxParams,
) -> Result<models::ListActionsResponse, Error<ListActionsForStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let sort = params.sort;
    let status = params.status;
    let page = params.page;
    let per_page = params.per_page;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/{id}/actions", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sort {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("sort".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "sort",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("status".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "status",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListActionsForStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of (sub)folders in a Storage Box.  The folder location is specified by the `path` query parameter.
pub async fn list_folders_of_storage_box(
    configuration: &configuration::Configuration,
    params: ListFoldersOfStorageBoxParams,
) -> Result<models::ListFoldersOfStorageBoxResponse, Error<ListFoldersOfStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let path = params.path;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/{id}/folders", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = path {
        local_var_req_builder =
            local_var_req_builder.query(&[("path", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListFoldersOfStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of Storage Box Snapshot.  Both snapshots created manually and by the snapshot plan are returned.
pub async fn list_snapshots(
    configuration: &configuration::Configuration,
    params: ListSnapshotsParams,
) -> Result<models::ListSnapshotsResponse, Error<ListSnapshotsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let name = params.name;
    let label_selector = params.label_selector;
    let sort = params.sort;
    let is_automatic = params.is_automatic;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/{id}/snapshots", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = name {
        local_var_req_builder =
            local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = label_selector {
        local_var_req_builder =
            local_var_req_builder.query(&[("label_selector", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("sort".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "sort",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = is_automatic {
        local_var_req_builder =
            local_var_req_builder.query(&[("is_automatic", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListSnapshotsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all Action objects.
pub async fn list_storage_box_actions(
    configuration: &configuration::Configuration,
    params: ListStorageBoxActionsParams,
) -> Result<models::ListActionsResponse, Error<ListStorageBoxActionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let sort = params.sort;
    let status = params.status;
    let page = params.page;
    let per_page = params.per_page;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/actions", local_base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "id",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("sort".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "sort",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("status".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "status",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListStorageBoxActionsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a paginated list of Storage Boxes.
pub async fn list_storage_boxes(
    configuration: &configuration::Configuration,
    params: ListStorageBoxesParams,
) -> Result<models::ListStorageBoxesResponse, Error<ListStorageBoxesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let label_selector = params.label_selector;
    let sort = params.sort;
    let page = params.page;
    let per_page = params.per_page;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes", local_base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = name {
        local_var_req_builder =
            local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = label_selector {
        local_var_req_builder =
            local_var_req_builder.query(&[("label_selector", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("sort".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "sort",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListStorageBoxesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of Storage Box Subaccount.
pub async fn list_subaccounts(
    configuration: &configuration::Configuration,
    params: ListSubaccountsParams,
) -> Result<models::ListSubaccountsResponse, Error<ListSubaccountsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let label_selector = params.label_selector;
    let sort = params.sort;
    let username = params.username;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = label_selector {
        local_var_req_builder =
            local_var_req_builder.query(&[("label_selector", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("sort".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "sort",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = username {
        local_var_req_builder =
            local_var_req_builder.query(&[("username", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListSubaccountsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a Storage Box Snapshot.
pub async fn replace_snapshot(
    configuration: &configuration::Configuration,
    params: ReplaceSnapshotParams,
) -> Result<models::ReplaceSnapshotResponse, Error<ReplaceSnapshotError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let snapshot_id = params.snapshot_id;
    let replace_snapshot_request = params.replace_snapshot_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/snapshots/{snapshot_id}",
        local_base_path,
        id = id,
        snapshot_id = snapshot_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&replace_snapshot_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReplaceSnapshotError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a Storage Box.
pub async fn replace_storage_box(
    configuration: &configuration::Configuration,
    params: ReplaceStorageBoxParams,
) -> Result<models::ReplaceStorageBoxResponse, Error<ReplaceStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let replace_storage_box_request = params.replace_storage_box_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/{id}", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&replace_storage_box_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReplaceStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a Storage Box Subaccount.
pub async fn replace_subaccount(
    configuration: &configuration::Configuration,
    params: ReplaceSubaccountParams,
) -> Result<models::ReplaceSubaccountResponse, Error<ReplaceSubaccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let subaccount_id = params.subaccount_id;
    let replace_subaccount_request = params.replace_subaccount_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts/{subaccount_id}",
        local_base_path,
        id = id,
        subaccount_id = subaccount_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&replace_subaccount_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReplaceSubaccountError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Reset the password of a Storage Box.
pub async fn reset_storage_box_password(
    configuration: &configuration::Configuration,
    params: ResetStorageBoxPasswordParams,
) -> Result<models::ResetPasswordResponse, Error<ResetStorageBoxPasswordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let reset_password_request = params.reset_password_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/reset_password",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&reset_password_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResetStorageBoxPasswordError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Reset the password of a Storage Box Subaccount.
pub async fn reset_storage_box_subaccount_password(
    configuration: &configuration::Configuration,
    params: ResetStorageBoxSubaccountPasswordParams,
) -> Result<models::ResetPasswordResponse, Error<ResetStorageBoxSubaccountPasswordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let subaccount_id = params.subaccount_id;
    let reset_password_request = params.reset_password_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts/{subaccount_id}/actions/reset_subaccount_password",
        local_base_path,
        id = id,
        subaccount_id = subaccount_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&reset_password_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResetStorageBoxSubaccountPasswordError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Rolls back a Storage Box to the given Storage Box Snapshot.  This will remove all newer Storage Box Snapshot and irrevocably delete all data that was since written to the Storage Box.
pub async fn rollback_snapshot(
    configuration: &configuration::Configuration,
    params: RollbackSnapshotParams,
) -> Result<models::RollbackSnapshotResponse, Error<RollbackSnapshotError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let rollback_snapshot_request = params.rollback_snapshot_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/rollback_snapshot",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&rollback_snapshot_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RollbackSnapshotError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update access settings of a primary Storage Box account.  This endpoints supports partial updates. Omitted optional parameters do not result in any changes to the respective properties.
pub async fn update_storage_box_access_settings(
    configuration: &configuration::Configuration,
    params: UpdateStorageBoxAccessSettingsParams,
) -> Result<models::UpdateAccessSettingsResponse, Error<UpdateStorageBoxAccessSettingsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let update_access_settings_request = params.update_access_settings_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/update_access_settings",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_access_settings_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateStorageBoxAccessSettingsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates the access settings of a Storage Box Subaccount.  This endpoints supports partial updates. Omitted optional parameters do not result in any changes to the respective properties.
pub async fn update_storage_box_subaccount_access_settings(
    configuration: &configuration::Configuration,
    params: UpdateStorageBoxSubaccountAccessSettingsParams,
) -> Result<
    models::UpdateAccessSettingsResponse,
    Error<UpdateStorageBoxSubaccountAccessSettingsError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let subaccount_id = params.subaccount_id;
    let update_access_settings_request = params.update_access_settings_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts/{subaccount_id}/actions/update_access_settings",
        local_base_path,
        id = id,
        subaccount_id = subaccount_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_access_settings_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateStorageBoxSubaccountAccessSettingsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
