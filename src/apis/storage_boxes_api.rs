/*
 * Hetzner Cloud API
 *
 * Copied from the official API documentation for the Public Hetzner Cloud.
 *
 * The version of the OpenAPI document: 0.26.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};

/// struct for passing parameters to the method [`change_storage_box_protection`]
#[derive(Clone, Debug, Default)]
pub struct ChangeStorageBoxProtectionParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub body: Option<models::Protection>,
}

/// struct for passing parameters to the method [`change_type_of_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct ChangeTypeOfStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub change_type_of_storage_box_request: Option<models::ChangeTypeOfStorageBoxRequest>,
}

/// struct for passing parameters to the method [`create_snapshot`]
#[derive(Clone, Debug, Default)]
pub struct CreateSnapshotParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub create_snapshot_request: Option<models::CreateSnapshotRequest>,
}

/// struct for passing parameters to the method [`create_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct CreateStorageBoxParams {
    pub create_storage_box_request: models::CreateStorageBoxRequest,
}

/// struct for passing parameters to the method [`create_subaccount`]
#[derive(Clone, Debug, Default)]
pub struct CreateSubaccountParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub create_subaccount_request: Option<models::CreateSubaccountRequest>,
}

/// struct for passing parameters to the method [`delete_snapshot`]
#[derive(Clone, Debug, Default)]
pub struct DeleteSnapshotParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Snapshot.
    pub snapshot_id: i64,
}

/// struct for passing parameters to the method [`delete_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct DeleteStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
}

/// struct for passing parameters to the method [`delete_subaccount`]
#[derive(Clone, Debug, Default)]
pub struct DeleteSubaccountParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Subaccount.
    pub subaccount_id: i64,
}

/// struct for passing parameters to the method [`disable_snapshot_plan`]
#[derive(Clone, Debug, Default)]
pub struct DisableSnapshotPlanParams {
    /// ID of the Storage Box.
    pub id: i64,
}

/// struct for passing parameters to the method [`enable_snapshot_plan`]
#[derive(Clone, Debug, Default)]
pub struct EnableSnapshotPlanParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub enable_snapshot_plan_request: Option<models::EnableSnapshotPlanRequest>,
}

/// struct for passing parameters to the method [`get_action_for_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct GetActionForStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Action.
    pub action_id: i64,
}

/// struct for passing parameters to the method [`get_snapshot`]
#[derive(Clone, Debug, Default)]
pub struct GetSnapshotParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Snapshot.
    pub snapshot_id: i64,
}

/// struct for passing parameters to the method [`get_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct GetStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
}

/// struct for passing parameters to the method [`get_storage_box_action`]
#[derive(Clone, Debug, Default)]
pub struct GetStorageBoxActionParams {
    /// ID of the Action.
    pub id: i64,
}

/// struct for passing parameters to the method [`get_subaccount`]
#[derive(Clone, Debug, Default)]
pub struct GetSubaccountParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Subaccount.
    pub subaccount_id: i64,
}

/// struct for passing parameters to the method [`list_actions_for_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct ListActionsForStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// Sort actions by field and direction. Can be used multiple times. For more information, see \"[Sorting](#sorting)\".
    pub sort: Option<Vec<String>>,
    /// Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.
    pub status: Option<Vec<String>>,
    /// Page number to return. For more information, see \"[Pagination](#pagination)\".
    pub page: Option<i64>,
    /// Maximum number of entries returned per page. For more information, see \"[Pagination](#pagination)\".
    pub per_page: Option<i64>,
}

/// struct for passing parameters to the method [`list_content_of_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct ListContentOfStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// Relative path for which the listing is to be made.
    pub path: Option<String>,
}

/// struct for passing parameters to the method [`list_snapshots_for_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct ListSnapshotsForStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// Filter resources by their name. The response will only contain the resources matching exactly the specified name.
    pub name: Option<String>,
    /// Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \"[Label Selector](#label-selector)\".
    pub label_selector: Option<String>,
}

/// struct for passing parameters to the method [`list_storage_box_actions`]
#[derive(Clone, Debug, Default)]
pub struct ListStorageBoxActionsParams {
    /// Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.
    pub id: Option<Vec<i64>>,
    /// Sort actions by field and direction. Can be used multiple times. For more information, see \"[Sorting](#sorting)\".
    pub sort: Option<Vec<String>>,
    /// Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.
    pub status: Option<Vec<String>>,
    /// Page number to return. For more information, see \"[Pagination](#pagination)\".
    pub page: Option<i64>,
    /// Maximum number of entries returned per page. For more information, see \"[Pagination](#pagination)\".
    pub per_page: Option<i64>,
}

/// struct for passing parameters to the method [`list_storage_boxes`]
#[derive(Clone, Debug, Default)]
pub struct ListStorageBoxesParams {
    /// Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \"[Label Selector](#label-selector)\".
    pub label_selector: Option<String>,
    /// Filter resources by their name. The response will only contain the resources matching exactly the specified name.
    pub name: Option<String>,
    /// Page number to return. For more information, see \"[Pagination](#pagination)\".
    pub page: Option<i64>,
    /// Maximum number of entries returned per page. For more information, see \"[Pagination](#pagination)\".
    pub per_page: Option<i64>,
}

/// struct for passing parameters to the method [`list_subaccounts_for_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct ListSubaccountsForStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \"[Label Selector](#label-selector)\".
    pub label_selector: Option<String>,
}

/// struct for passing parameters to the method [`replace_snapshot`]
#[derive(Clone, Debug, Default)]
pub struct ReplaceSnapshotParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Snapshot.
    pub snapshot_id: i64,
    pub replace_snapshot_request: models::ReplaceSnapshotRequest,
}

/// struct for passing parameters to the method [`replace_storage_box`]
#[derive(Clone, Debug, Default)]
pub struct ReplaceStorageBoxParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub replace_storage_box_request: models::ReplaceStorageBoxRequest,
}

/// struct for passing parameters to the method [`replace_subaccount`]
#[derive(Clone, Debug, Default)]
pub struct ReplaceSubaccountParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Subaccount.
    pub subaccount_id: i64,
    pub replace_subaccount_request: models::ReplaceSubaccountRequest,
}

/// struct for passing parameters to the method [`reset_storage_box_password`]
#[derive(Clone, Debug, Default)]
pub struct ResetStorageBoxPasswordParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub reset_password_request: Option<models::ResetPasswordRequest>,
}

/// struct for passing parameters to the method [`reset_storage_box_subaccount_password`]
#[derive(Clone, Debug, Default)]
pub struct ResetStorageBoxSubaccountPasswordParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Subaccount.
    pub subaccount_id: i64,
    pub reset_password_request: Option<models::ResetPasswordRequest>,
}

/// struct for passing parameters to the method [`rollback_snapshot`]
#[derive(Clone, Debug, Default)]
pub struct RollbackSnapshotParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub rollback_snapshot_request: Option<models::RollbackSnapshotRequest>,
}

/// struct for passing parameters to the method [`update_storage_box_access_settings`]
#[derive(Clone, Debug, Default)]
pub struct UpdateStorageBoxAccessSettingsParams {
    /// ID of the Storage Box.
    pub id: i64,
    pub update_access_settings_request: Option<models::UpdateAccessSettingsRequest>,
}

/// struct for passing parameters to the method [`update_storage_box_subaccount_access_settings`]
#[derive(Clone, Debug, Default)]
pub struct UpdateStorageBoxSubaccountAccessSettingsParams {
    /// ID of the Storage Box.
    pub id: i64,
    /// ID of the Storage Box Subaccount.
    pub subaccount_id: i64,
    pub update_access_settings_request: Option<models::UpdateAccessSettingsRequest>,
}

/// struct for typed errors of method [`change_storage_box_protection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeStorageBoxProtectionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_type_of_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeTypeOfStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_snapshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSnapshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_subaccount`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSubaccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_snapshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSnapshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_subaccount`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSubaccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`disable_snapshot_plan`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DisableSnapshotPlanError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enable_snapshot_plan`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnableSnapshotPlanError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_action_for_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActionForStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_snapshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSnapshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_storage_box_action`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStorageBoxActionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_subaccount`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubaccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_actions_for_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListActionsForStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_content_of_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListContentOfStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_snapshots_for_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSnapshotsForStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_storage_box_actions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListStorageBoxActionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_storage_boxes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListStorageBoxesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_subaccounts_for_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSubaccountsForStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`replace_snapshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceSnapshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`replace_storage_box`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceStorageBoxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`replace_subaccount`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceSubaccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_storage_box_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetStorageBoxPasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_storage_box_subaccount_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetStorageBoxSubaccountPasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rollback_snapshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RollbackSnapshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_storage_box_access_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateStorageBoxAccessSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_storage_box_subaccount_access_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateStorageBoxSubaccountAccessSettingsError {
    UnknownValue(serde_json::Value),
}

/// Changes the protection configuration of the Storage Box.
pub async fn change_storage_box_protection(
    configuration: &configuration::Configuration,
    params: ChangeStorageBoxProtectionParams,
) -> Result<models::ChangeStorageBoxProtectionResponse, Error<ChangeStorageBoxProtectionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let body = params.body;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/change_protection",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChangeStorageBoxProtectionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Requests a Storage Box to be upgraded or downgraded to another Storage Box Type.  Please note that it is not possible to downgrade to a Storage Box Type that offers less disk space than you are currently using.
pub async fn change_type_of_storage_box(
    configuration: &configuration::Configuration,
    params: ChangeTypeOfStorageBoxParams,
) -> Result<models::ChangeTypeOfStorageBoxResponse, Error<ChangeTypeOfStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let change_type_of_storage_box_request = params.change_type_of_storage_box_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/change_type",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&change_type_of_storage_box_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChangeTypeOfStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a new Snapshot.
pub async fn create_snapshot(
    configuration: &configuration::Configuration,
    params: CreateSnapshotParams,
) -> Result<models::CreateSnapshotResponse, Error<CreateSnapshotError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let create_snapshot_request = params.create_snapshot_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/{id}/snapshots", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_snapshot_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateSnapshotError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a new Storage Box. Returns an Action that covers progress of creation.
pub async fn create_storage_box(
    configuration: &configuration::Configuration,
    params: CreateStorageBoxParams,
) -> Result<models::CreateStorageBoxResponse, Error<CreateStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let create_storage_box_request = params.create_storage_box_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes", local_base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_storage_box_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a new Subaccount with a separate home directory.
pub async fn create_subaccount(
    configuration: &configuration::Configuration,
    params: CreateSubaccountParams,
) -> Result<models::CreateSubaccountResponse, Error<CreateSubaccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let create_subaccount_request = params.create_subaccount_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_subaccount_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateSubaccountError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete the given Snapshot.
pub async fn delete_snapshot(
    configuration: &configuration::Configuration,
    params: DeleteSnapshotParams,
) -> Result<models::DeleteSnapshotResponse, Error<DeleteSnapshotError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let snapshot_id = params.snapshot_id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/snapshots/{snapshot_id}",
        local_base_path,
        id = id,
        snapshot_id = snapshot_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteSnapshotError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes an existing Storage Box.
pub async fn delete_storage_box(
    configuration: &configuration::Configuration,
    params: DeleteStorageBoxParams,
) -> Result<models::DeleteStorageBoxResponse, Error<DeleteStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/{id}", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes an existing subaccount.
pub async fn delete_subaccount(
    configuration: &configuration::Configuration,
    params: DeleteSubaccountParams,
) -> Result<models::DeleteSubaccountResponse, Error<DeleteSubaccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let subaccount_id = params.subaccount_id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts/{subaccount_id}",
        local_base_path,
        id = id,
        subaccount_id = subaccount_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteSubaccountError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Disables the active Snapshot Plan.  This action doesn't result in the deletion of the Snapshots created by the Snapshot Plan. They must be removed manually.
pub async fn disable_snapshot_plan(
    configuration: &configuration::Configuration,
    params: DisableSnapshotPlanParams,
) -> Result<models::DisableSnapshotPlanResponse, Error<DisableSnapshotPlanError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/disable_snapshot_plan",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DisableSnapshotPlanError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Enables a Snapshot Plan for a given StorageBox. Once enabled, a Snapshot Plan will create Snapshots at predefined intervals. There can only ever be one Snapshot Plan. The existing Snapshot Plan will be deleted before a new one is set up.  Automatic Snapshots are retained until explicitly deleted by the user or the maximum snapshot count for the plan (\"max_snapshots\") is exceeded.  You can choose the specific time (UTC timezone), day of the week, and day of the month. The time-related options are cron like. Some typical use cases include:  | Interval                                   | Request body                                                  | | ------------------------------------------ | ------------------------------------------------------------- | | Every day at 3 o'clock                     | `{\"max_snapshots\":10,\"minute\":0,\"hour\":3}`                    | | Every Friday at 3 o'clock                  | `{\"max_snapshots\":10,\"minute\":0,\"hour\":3,\"day_of_week\": 5}`   | | On the first of every month at half past 6 | `{\"max_snapshots\":10,\"minute\":30,\"hour\":6,\"day_of_month\": 1}` |
pub async fn enable_snapshot_plan(
    configuration: &configuration::Configuration,
    params: EnableSnapshotPlanParams,
) -> Result<models::EnableSnapshotPlanResponse, Error<EnableSnapshotPlanError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let enable_snapshot_plan_request = params.enable_snapshot_plan_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/enable_snapshot_plan",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&enable_snapshot_plan_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EnableSnapshotPlanError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a specific Action object for a Storage Box.
pub async fn get_action_for_storage_box(
    configuration: &configuration::Configuration,
    params: GetActionForStorageBoxParams,
) -> Result<models::GetActionResponse, Error<GetActionForStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let action_id = params.action_id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/{action_id}",
        local_base_path,
        id = id,
        action_id = action_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetActionForStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a specific Snapshot object.
pub async fn get_snapshot(
    configuration: &configuration::Configuration,
    params: GetSnapshotParams,
) -> Result<models::GetSnapshotResponse, Error<GetSnapshotError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let snapshot_id = params.snapshot_id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/snapshots/{snapshot_id}",
        local_base_path,
        id = id,
        snapshot_id = snapshot_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSnapshotError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a specific Storage Box object. The Storage Box must exist inside the Project.
pub async fn get_storage_box(
    configuration: &configuration::Configuration,
    params: GetStorageBoxParams,
) -> Result<models::GetStorageBoxResponse, Error<GetStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/{id}", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a specific Action object.
pub async fn get_storage_box_action(
    configuration: &configuration::Configuration,
    params: GetStorageBoxActionParams,
) -> Result<models::GetActionResponse, Error<GetStorageBoxActionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/actions/{id}", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetStorageBoxActionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a specific Subaccount object.
pub async fn get_subaccount(
    configuration: &configuration::Configuration,
    params: GetSubaccountParams,
) -> Result<models::GetSubaccountResponse, Error<GetSubaccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let subaccount_id = params.subaccount_id;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts/{subaccount_id}",
        local_base_path,
        id = id,
        subaccount_id = subaccount_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSubaccountError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all Actions related to a specific Storage Box.
pub async fn list_actions_for_storage_box(
    configuration: &configuration::Configuration,
    params: ListActionsForStorageBoxParams,
) -> Result<models::ListActionsResponse, Error<ListActionsForStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let sort = params.sort;
    let status = params.status;
    let page = params.page;
    let per_page = params.per_page;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/{id}/actions", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sort {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("sort".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "sort",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("status".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "status",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListActionsForStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists the (sub)folders contained in a Storage Box at the location specified by the path. Files are not part of the response.
pub async fn list_content_of_storage_box(
    configuration: &configuration::Configuration,
    params: ListContentOfStorageBoxParams,
) -> Result<models::ListContentOfStorageBoxResponse, Error<ListContentOfStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let path = params.path;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/{id}/folders", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = path {
        local_var_req_builder =
            local_var_req_builder.query(&[("path", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListContentOfStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all Snapshots created both manually and through the Snapshot Plan.
pub async fn list_snapshots_for_storage_box(
    configuration: &configuration::Configuration,
    params: ListSnapshotsForStorageBoxParams,
) -> Result<models::ListSnapshotsForStorageBoxResponse, Error<ListSnapshotsForStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let name = params.name;
    let label_selector = params.label_selector;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/{id}/snapshots", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = name {
        local_var_req_builder =
            local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = label_selector {
        local_var_req_builder =
            local_var_req_builder.query(&[("label_selector", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListSnapshotsForStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all Action objects.
pub async fn list_storage_box_actions(
    configuration: &configuration::Configuration,
    params: ListStorageBoxActionsParams,
) -> Result<models::ListActionsResponse, Error<ListStorageBoxActionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let sort = params.sort;
    let status = params.status;
    let page = params.page;
    let per_page = params.per_page;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/actions", local_base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "id",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("sort".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "sort",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("status".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "status",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListStorageBoxActionsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all existing Storage Box objects.
pub async fn list_storage_boxes(
    configuration: &configuration::Configuration,
    params: ListStorageBoxesParams,
) -> Result<models::ListStorageBoxesResponse, Error<ListStorageBoxesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let label_selector = params.label_selector;
    let name = params.name;
    let page = params.page;
    let per_page = params.per_page;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes", local_base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = label_selector {
        local_var_req_builder =
            local_var_req_builder.query(&[("label_selector", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name {
        local_var_req_builder =
            local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListStorageBoxesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a list of all available Subaccounts.
pub async fn list_subaccounts_for_storage_box(
    configuration: &configuration::Configuration,
    params: ListSubaccountsForStorageBoxParams,
) -> Result<models::ListSubaccountsForStorageBoxResponse, Error<ListSubaccountsForStorageBoxError>>
{
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let label_selector = params.label_selector;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = label_selector {
        local_var_req_builder =
            local_var_req_builder.query(&[("label_selector", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListSubaccountsForStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates the name and labels of a Snapshot.
pub async fn replace_snapshot(
    configuration: &configuration::Configuration,
    params: ReplaceSnapshotParams,
) -> Result<models::ReplaceSnapshotResponse, Error<ReplaceSnapshotError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let snapshot_id = params.snapshot_id;
    let replace_snapshot_request = params.replace_snapshot_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/snapshots/{snapshot_id}",
        local_base_path,
        id = id,
        snapshot_id = snapshot_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&replace_snapshot_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReplaceSnapshotError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a Storage Box. You can update a Storage Boxes' name and labels.
pub async fn replace_storage_box(
    configuration: &configuration::Configuration,
    params: ReplaceStorageBoxParams,
) -> Result<models::ReplaceStorageBoxResponse, Error<ReplaceStorageBoxError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let replace_storage_box_request = params.replace_storage_box_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!("{}/storage_boxes/{id}", local_base_path, id = id);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&replace_storage_box_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReplaceStorageBoxError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates the description and the labels of a Subaccount.
pub async fn replace_subaccount(
    configuration: &configuration::Configuration,
    params: ReplaceSubaccountParams,
) -> Result<models::ReplaceSubaccountResponse, Error<ReplaceSubaccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let subaccount_id = params.subaccount_id;
    let replace_subaccount_request = params.replace_subaccount_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts/{subaccount_id}",
        local_base_path,
        id = id,
        subaccount_id = subaccount_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&replace_subaccount_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReplaceSubaccountError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Reset the password of the given Storage Box.
pub async fn reset_storage_box_password(
    configuration: &configuration::Configuration,
    params: ResetStorageBoxPasswordParams,
) -> Result<models::ResetPasswordResponse, Error<ResetStorageBoxPasswordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let reset_password_request = params.reset_password_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/reset_password",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&reset_password_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResetStorageBoxPasswordError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Reset the password of the given Subaccount.
pub async fn reset_storage_box_subaccount_password(
    configuration: &configuration::Configuration,
    params: ResetStorageBoxSubaccountPasswordParams,
) -> Result<models::ResetPasswordResponse, Error<ResetStorageBoxSubaccountPasswordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let subaccount_id = params.subaccount_id;
    let reset_password_request = params.reset_password_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts/{subaccount_id}/actions/reset_subaccount_password",
        local_base_path,
        id = id,
        subaccount_id = subaccount_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&reset_password_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResetStorageBoxSubaccountPasswordError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Rolls back the Storage Box to the given Snapshot.  This action will remove all newer Snapshots and irrevocably delete all data that was since written to the Storage Box.
pub async fn rollback_snapshot(
    configuration: &configuration::Configuration,
    params: RollbackSnapshotParams,
) -> Result<models::RollbackSnapshotResponse, Error<RollbackSnapshotError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let rollback_snapshot_request = params.rollback_snapshot_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/rollback_snapshot",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&rollback_snapshot_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RollbackSnapshotError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update access settings of the primary Storage Box account.  This endpoints supports partial updates. Omitted optional parameters do not result in any changes to the respective properties.
pub async fn update_storage_box_access_settings(
    configuration: &configuration::Configuration,
    params: UpdateStorageBoxAccessSettingsParams,
) -> Result<models::UpdateAccessSettingsResponse, Error<UpdateStorageBoxAccessSettingsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let update_access_settings_request = params.update_access_settings_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/actions/update_access_settings",
        local_base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_access_settings_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateStorageBoxAccessSettingsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates the access settings of a Subaccount.  This endpoints supports partial updates. Omitted optional parameters do not result in any changes to the respective properties.
pub async fn update_storage_box_subaccount_access_settings(
    configuration: &configuration::Configuration,
    params: UpdateStorageBoxSubaccountAccessSettingsParams,
) -> Result<
    models::UpdateAccessSettingsResponse,
    Error<UpdateStorageBoxSubaccountAccessSettingsError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let subaccount_id = params.subaccount_id;
    let update_access_settings_request = params.update_access_settings_request;

    let local_var_client = &local_var_configuration.client;

    let local_base_path = local_var_configuration.get_base_path("https://api.hetzner.com/v1");
    let local_var_uri_str = format!(
        "{}/storage_boxes/{id}/subaccounts/{subaccount_id}/actions/update_access_settings",
        local_base_path,
        id = id,
        subaccount_id = subaccount_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_access_settings_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateStorageBoxSubaccountAccessSettingsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
